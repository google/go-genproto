// Code generated by protoc-gen-go.
// source: google.golang.org/genproto/googleapis/cloud/speech/v1beta1/cloud_speech.proto
// DO NOT EDIT!

/*
Package google_cloud_speech_v1beta1 is a generated protocol buffer package.

It is generated from these files:
	google.golang.org/genproto/googleapis/cloud/speech/v1beta1/cloud_speech.proto

It has these top-level messages:
	SyncRecognizeRequest
	AsyncRecognizeRequest
	StreamingRecognizeRequest
	StreamingRecognitionConfig
	RecognitionConfig
	SpeechContext
	RecognitionAudio
	SyncRecognizeResponse
	AsyncRecognizeResponse
	StreamingRecognizeResponse
	StreamingRecognitionResult
	SpeechRecognitionResult
	SpeechRecognitionAlternative
*/
package google_cloud_speech_v1beta1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/serviceconfig"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Audio encoding of the data sent in the audio message. All encodings support
// only 1 channel (mono) audio. Only `FLAC` includes a header that describes
// the bytes of audio that follow the header. The other encodings are raw
// audio bytes with no header.
//
// For best results, the audio source should be captured and transmitted using
// a lossless encoding (`FLAC` or `LINEAR16`). Recognition accuracy may be
// reduced if lossy codecs (such as AMR, AMR_WB and MULAW) are used to capture
// or transmit the audio, particularly if background noise is present.
type RecognitionConfig_AudioEncoding int32

const (
	// Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
	RecognitionConfig_ENCODING_UNSPECIFIED RecognitionConfig_AudioEncoding = 0
	// Uncompressed 16-bit signed little-endian samples.
	// This is the only encoding that may be used by `AsyncRecognize`.
	RecognitionConfig_LINEAR16 RecognitionConfig_AudioEncoding = 1
	// This is the recommended encoding for `SyncRecognize` and
	// `StreamingRecognize` because it uses lossless compression; therefore
	// recognition accuracy is not compromised by a lossy codec.
	//
	// The stream FLAC (Free Lossless Audio Codec) encoding is specified at:
	// http://flac.sourceforge.net/documentation.html.
	// Only 16-bit samples are supported.
	// Not all fields in STREAMINFO are supported.
	RecognitionConfig_FLAC RecognitionConfig_AudioEncoding = 2
	// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
	RecognitionConfig_MULAW RecognitionConfig_AudioEncoding = 3
	// Adaptive Multi-Rate Narrowband codec. `sample_rate` must be 8000 Hz.
	RecognitionConfig_AMR RecognitionConfig_AudioEncoding = 4
	// Adaptive Multi-Rate Wideband codec. `sample_rate` must be 16000 Hz.
	RecognitionConfig_AMR_WB RecognitionConfig_AudioEncoding = 5
)

var RecognitionConfig_AudioEncoding_name = map[int32]string{
	0: "ENCODING_UNSPECIFIED",
	1: "LINEAR16",
	2: "FLAC",
	3: "MULAW",
	4: "AMR",
	5: "AMR_WB",
}
var RecognitionConfig_AudioEncoding_value = map[string]int32{
	"ENCODING_UNSPECIFIED": 0,
	"LINEAR16":             1,
	"FLAC":                 2,
	"MULAW":                3,
	"AMR":                  4,
	"AMR_WB":               5,
}

func (x RecognitionConfig_AudioEncoding) String() string {
	return proto.EnumName(RecognitionConfig_AudioEncoding_name, int32(x))
}
func (RecognitionConfig_AudioEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

// Indicates the type of endpointer event.
type StreamingRecognizeResponse_EndpointerType int32

const (
	// No endpointer event specified.
	StreamingRecognizeResponse_ENDPOINTER_EVENT_UNSPECIFIED StreamingRecognizeResponse_EndpointerType = 0
	// Speech has been detected in the audio stream.
	StreamingRecognizeResponse_START_OF_SPEECH StreamingRecognizeResponse_EndpointerType = 1
	// Speech has ceased to be detected in the audio stream.
	StreamingRecognizeResponse_END_OF_SPEECH StreamingRecognizeResponse_EndpointerType = 2
	// The end of the audio stream has been reached. and it is being processed.
	StreamingRecognizeResponse_END_OF_AUDIO StreamingRecognizeResponse_EndpointerType = 3
	// This event is only sent when `single_utterance` is `true`. It indicates
	// that the server has detected the end of the user's speech utterance and
	// expects no additional speech. Therefore, the server will not process
	// additional audio. The client should stop sending additional audio data.
	StreamingRecognizeResponse_END_OF_UTTERANCE StreamingRecognizeResponse_EndpointerType = 4
)

var StreamingRecognizeResponse_EndpointerType_name = map[int32]string{
	0: "ENDPOINTER_EVENT_UNSPECIFIED",
	1: "START_OF_SPEECH",
	2: "END_OF_SPEECH",
	3: "END_OF_AUDIO",
	4: "END_OF_UTTERANCE",
}
var StreamingRecognizeResponse_EndpointerType_value = map[string]int32{
	"ENDPOINTER_EVENT_UNSPECIFIED": 0,
	"START_OF_SPEECH":              1,
	"END_OF_SPEECH":                2,
	"END_OF_AUDIO":                 3,
	"END_OF_UTTERANCE":             4,
}

func (x StreamingRecognizeResponse_EndpointerType) String() string {
	return proto.EnumName(StreamingRecognizeResponse_EndpointerType_name, int32(x))
}
func (StreamingRecognizeResponse_EndpointerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{9, 0}
}

// `SyncRecognizeRequest` is the top-level message sent by the client for
// the `SyncRecognize` method.
type SyncRecognizeRequest struct {
	// [Required] The `config` message provides information to the recognizer
	// that specifies how to process the request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// [Required] The audio data to be recognized.
	Audio *RecognitionAudio `protobuf:"bytes,2,opt,name=audio" json:"audio,omitempty"`
}

func (m *SyncRecognizeRequest) Reset()                    { *m = SyncRecognizeRequest{} }
func (m *SyncRecognizeRequest) String() string            { return proto.CompactTextString(m) }
func (*SyncRecognizeRequest) ProtoMessage()               {}
func (*SyncRecognizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SyncRecognizeRequest) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *SyncRecognizeRequest) GetAudio() *RecognitionAudio {
	if m != nil {
		return m.Audio
	}
	return nil
}

// `AsyncRecognizeRequest` is the top-level message sent by the client for
// the `AsyncRecognize` method.
type AsyncRecognizeRequest struct {
	// [Required] The `config` message provides information to the recognizer
	// that specifies how to process the request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// [Required] The audio data to be recognized.
	Audio *RecognitionAudio `protobuf:"bytes,2,opt,name=audio" json:"audio,omitempty"`
}

func (m *AsyncRecognizeRequest) Reset()                    { *m = AsyncRecognizeRequest{} }
func (m *AsyncRecognizeRequest) String() string            { return proto.CompactTextString(m) }
func (*AsyncRecognizeRequest) ProtoMessage()               {}
func (*AsyncRecognizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AsyncRecognizeRequest) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *AsyncRecognizeRequest) GetAudio() *RecognitionAudio {
	if m != nil {
		return m.Audio
	}
	return nil
}

// `StreamingRecognizeRequest` is the top-level message sent by the client for
// the `StreamingRecognize`. Multiple `StreamingRecognizeRequest` messages are
// sent. The first message must contain a `streaming_config` message and must
// not contain `audio` data. All subsequent messages must contain `audio` data
// and must not contain a `streaming_config` message.
type StreamingRecognizeRequest struct {
	// Types that are valid to be assigned to StreamingRequest:
	//	*StreamingRecognizeRequest_StreamingConfig
	//	*StreamingRecognizeRequest_AudioContent
	StreamingRequest isStreamingRecognizeRequest_StreamingRequest `protobuf_oneof:"streaming_request"`
}

func (m *StreamingRecognizeRequest) Reset()                    { *m = StreamingRecognizeRequest{} }
func (m *StreamingRecognizeRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamingRecognizeRequest) ProtoMessage()               {}
func (*StreamingRecognizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isStreamingRecognizeRequest_StreamingRequest interface {
	isStreamingRecognizeRequest_StreamingRequest()
}

type StreamingRecognizeRequest_StreamingConfig struct {
	StreamingConfig *StreamingRecognitionConfig `protobuf:"bytes,1,opt,name=streaming_config,json=streamingConfig,oneof"`
}
type StreamingRecognizeRequest_AudioContent struct {
	AudioContent []byte `protobuf:"bytes,2,opt,name=audio_content,json=audioContent,proto3,oneof"`
}

func (*StreamingRecognizeRequest_StreamingConfig) isStreamingRecognizeRequest_StreamingRequest() {}
func (*StreamingRecognizeRequest_AudioContent) isStreamingRecognizeRequest_StreamingRequest()    {}

func (m *StreamingRecognizeRequest) GetStreamingRequest() isStreamingRecognizeRequest_StreamingRequest {
	if m != nil {
		return m.StreamingRequest
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetStreamingConfig() *StreamingRecognitionConfig {
	if x, ok := m.GetStreamingRequest().(*StreamingRecognizeRequest_StreamingConfig); ok {
		return x.StreamingConfig
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetAudioContent() []byte {
	if x, ok := m.GetStreamingRequest().(*StreamingRecognizeRequest_AudioContent); ok {
		return x.AudioContent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamingRecognizeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamingRecognizeRequest_OneofMarshaler, _StreamingRecognizeRequest_OneofUnmarshaler, _StreamingRecognizeRequest_OneofSizer, []interface{}{
		(*StreamingRecognizeRequest_StreamingConfig)(nil),
		(*StreamingRecognizeRequest_AudioContent)(nil),
	}
}

func _StreamingRecognizeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamingRecognizeRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecognizeRequest_StreamingConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamingConfig); err != nil {
			return err
		}
	case *StreamingRecognizeRequest_AudioContent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.AudioContent)
	case nil:
	default:
		return fmt.Errorf("StreamingRecognizeRequest.StreamingRequest has unexpected type %T", x)
	}
	return nil
}

func _StreamingRecognizeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamingRecognizeRequest)
	switch tag {
	case 1: // streaming_request.streaming_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamingRecognitionConfig)
		err := b.DecodeMessage(msg)
		m.StreamingRequest = &StreamingRecognizeRequest_StreamingConfig{msg}
		return true, err
	case 2: // streaming_request.audio_content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.StreamingRequest = &StreamingRecognizeRequest_AudioContent{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamingRecognizeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamingRecognizeRequest)
	// streaming_request
	switch x := m.StreamingRequest.(type) {
	case *StreamingRecognizeRequest_StreamingConfig:
		s := proto.Size(x.StreamingConfig)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamingRecognizeRequest_AudioContent:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AudioContent)))
		n += len(x.AudioContent)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The `StreamingRecognitionConfig` message provides information to the
// recognizer that specifies how to process the request.
type StreamingRecognitionConfig struct {
	// [Required] The `config` message provides information to the recognizer
	// that specifies how to process the request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// [Optional] If `false` or omitted, the recognizer will perform continuous
	// recognition (continuing to process audio even if the user pauses speaking)
	// until the client closes the output stream (gRPC API) or when the maximum
	// time limit has been reached. Multiple `SpeechRecognitionResult`s with the
	// `is_final` flag set to `true` may be returned.
	//
	// If `true`, the recognizer will detect a single spoken utterance. When it
	// detects that the user has paused or stopped speaking, it will return an
	// `END_OF_UTTERANCE` event and cease recognition. It will return no more than
	// one `SpeechRecognitionResult` with the `is_final` flag set to `true`.
	SingleUtterance bool `protobuf:"varint,2,opt,name=single_utterance,json=singleUtterance" json:"single_utterance,omitempty"`
	// [Optional] If `true`, interim results (tentative hypotheses) may be
	// returned as they become available (these interim results are indicated with
	// the `is_final=false` flag).
	// If `false` or omitted, only `is_final=true` result(s) are returned.
	InterimResults bool `protobuf:"varint,3,opt,name=interim_results,json=interimResults" json:"interim_results,omitempty"`
}

func (m *StreamingRecognitionConfig) Reset()                    { *m = StreamingRecognitionConfig{} }
func (m *StreamingRecognitionConfig) String() string            { return proto.CompactTextString(m) }
func (*StreamingRecognitionConfig) ProtoMessage()               {}
func (*StreamingRecognitionConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StreamingRecognitionConfig) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

// The `RecognitionConfig` message provides information to the recognizer
// that specifies how to process the request.
type RecognitionConfig struct {
	// [Required] Encoding of audio data sent in all `RecognitionAudio` messages.
	Encoding RecognitionConfig_AudioEncoding `protobuf:"varint,1,opt,name=encoding,enum=google.cloud.speech.v1beta1.RecognitionConfig_AudioEncoding" json:"encoding,omitempty"`
	// [Required] Sample rate in Hertz of the audio data sent in all
	// `RecognitionAudio` messages. Valid values are: 8000-48000.
	// 16000 is optimal. For best results, set the sampling rate of the audio
	// source to 16000 Hz. If that's not possible, use the native sample rate of
	// the audio source (instead of re-sampling).
	SampleRate int32 `protobuf:"varint,2,opt,name=sample_rate,json=sampleRate" json:"sample_rate,omitempty"`
	// [Optional] The language of the supplied audio as a BCP-47 language tag.
	// Example: "en-GB"  https://www.rfc-editor.org/rfc/bcp/bcp47.txt
	// If omitted, defaults to "en-US". See
	// [Language Support](/speech/docs/best-practices#language_support) for
	// a list of the currently supported language codes.
	LanguageCode string `protobuf:"bytes,3,opt,name=language_code,json=languageCode" json:"language_code,omitempty"`
	// [Optional] Maximum number of recognition hypotheses to be returned.
	// Specifically, the maximum number of `SpeechRecognitionAlternative` messages
	// within each `SpeechRecognitionResult`.
	// The server may return fewer than `max_alternatives`.
	// Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
	// `1`. If omitted, defaults to `1`.
	MaxAlternatives int32 `protobuf:"varint,4,opt,name=max_alternatives,json=maxAlternatives" json:"max_alternatives,omitempty"`
	// [Optional] If set to `true`, the server will attempt to filter out
	// profanities, replacing all but the initial character in each filtered word
	// with asterisks, e.g. "f***". If set to `false` or omitted, profanities
	// won't be filtered out.
	ProfanityFilter bool `protobuf:"varint,5,opt,name=profanity_filter,json=profanityFilter" json:"profanity_filter,omitempty"`
	// [Optional] A means to provide context to assist the speech recognition.
	SpeechContext *SpeechContext `protobuf:"bytes,6,opt,name=speech_context,json=speechContext" json:"speech_context,omitempty"`
}

func (m *RecognitionConfig) Reset()                    { *m = RecognitionConfig{} }
func (m *RecognitionConfig) String() string            { return proto.CompactTextString(m) }
func (*RecognitionConfig) ProtoMessage()               {}
func (*RecognitionConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RecognitionConfig) GetSpeechContext() *SpeechContext {
	if m != nil {
		return m.SpeechContext
	}
	return nil
}

// Provides "hints" to the speech recognizer to favor specific words and phrases
// in the results.
type SpeechContext struct {
	// [Optional] A list of up to 50 phrases of up to 100 characters each to
	// provide words and phrases "hints" to the speech recognition so that it is
	// more likely to recognize them.
	Phrases []string `protobuf:"bytes,1,rep,name=phrases" json:"phrases,omitempty"`
}

func (m *SpeechContext) Reset()                    { *m = SpeechContext{} }
func (m *SpeechContext) String() string            { return proto.CompactTextString(m) }
func (*SpeechContext) ProtoMessage()               {}
func (*SpeechContext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Contains audio data in the encoding specified in the `RecognitionConfig`.
// Either `content` or `uri` must be supplied. Supplying both or neither
// returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
type RecognitionAudio struct {
	// Types that are valid to be assigned to AudioSource:
	//	*RecognitionAudio_Content
	//	*RecognitionAudio_Uri
	AudioSource isRecognitionAudio_AudioSource `protobuf_oneof:"audio_source"`
}

func (m *RecognitionAudio) Reset()                    { *m = RecognitionAudio{} }
func (m *RecognitionAudio) String() string            { return proto.CompactTextString(m) }
func (*RecognitionAudio) ProtoMessage()               {}
func (*RecognitionAudio) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isRecognitionAudio_AudioSource interface {
	isRecognitionAudio_AudioSource()
}

type RecognitionAudio_Content struct {
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3,oneof"`
}
type RecognitionAudio_Uri struct {
	Uri string `protobuf:"bytes,2,opt,name=uri,oneof"`
}

func (*RecognitionAudio_Content) isRecognitionAudio_AudioSource() {}
func (*RecognitionAudio_Uri) isRecognitionAudio_AudioSource()     {}

func (m *RecognitionAudio) GetAudioSource() isRecognitionAudio_AudioSource {
	if m != nil {
		return m.AudioSource
	}
	return nil
}

func (m *RecognitionAudio) GetContent() []byte {
	if x, ok := m.GetAudioSource().(*RecognitionAudio_Content); ok {
		return x.Content
	}
	return nil
}

func (m *RecognitionAudio) GetUri() string {
	if x, ok := m.GetAudioSource().(*RecognitionAudio_Uri); ok {
		return x.Uri
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RecognitionAudio) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RecognitionAudio_OneofMarshaler, _RecognitionAudio_OneofUnmarshaler, _RecognitionAudio_OneofSizer, []interface{}{
		(*RecognitionAudio_Content)(nil),
		(*RecognitionAudio_Uri)(nil),
	}
}

func _RecognitionAudio_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RecognitionAudio)
	// audio_source
	switch x := m.AudioSource.(type) {
	case *RecognitionAudio_Content:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Content)
	case *RecognitionAudio_Uri:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Uri)
	case nil:
	default:
		return fmt.Errorf("RecognitionAudio.AudioSource has unexpected type %T", x)
	}
	return nil
}

func _RecognitionAudio_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RecognitionAudio)
	switch tag {
	case 1: // audio_source.content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.AudioSource = &RecognitionAudio_Content{x}
		return true, err
	case 2: // audio_source.uri
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.AudioSource = &RecognitionAudio_Uri{x}
		return true, err
	default:
		return false, nil
	}
}

func _RecognitionAudio_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RecognitionAudio)
	// audio_source
	switch x := m.AudioSource.(type) {
	case *RecognitionAudio_Content:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case *RecognitionAudio_Uri:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Uri)))
		n += len(x.Uri)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// `SyncRecognizeResponse` is the only message returned to the client by
// `SyncRecognize`. It contains the result as zero or more
// sequential `RecognizeResponse` messages.
type SyncRecognizeResponse struct {
	// [Output-only] Sequential list of transcription results corresponding to
	// sequential portions of audio.
	Results []*SpeechRecognitionResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *SyncRecognizeResponse) Reset()                    { *m = SyncRecognizeResponse{} }
func (m *SyncRecognizeResponse) String() string            { return proto.CompactTextString(m) }
func (*SyncRecognizeResponse) ProtoMessage()               {}
func (*SyncRecognizeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SyncRecognizeResponse) GetResults() []*SpeechRecognitionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// `AsyncRecognizeResponse` is the only message returned to the client by
// `AsyncRecognize`. It contains the result as zero or more
// sequential `RecognizeResponse` messages.
type AsyncRecognizeResponse struct {
	// [Output-only] Sequential list of transcription results corresponding to
	// sequential portions of audio.
	Results []*SpeechRecognitionResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *AsyncRecognizeResponse) Reset()                    { *m = AsyncRecognizeResponse{} }
func (m *AsyncRecognizeResponse) String() string            { return proto.CompactTextString(m) }
func (*AsyncRecognizeResponse) ProtoMessage()               {}
func (*AsyncRecognizeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AsyncRecognizeResponse) GetResults() []*SpeechRecognitionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// `StreamingRecognizeResponse` is the only message returned to the client by
// `StreamingRecognize`. It contains the result as zero or more
// sequential `RecognizeResponse` messages.
type StreamingRecognizeResponse struct {
	// [Output-only] If set, returns a [google.rpc.Status][] message that
	// specifies the error for the operation.
	Error *google_rpc.Status `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// [Output-only] This repeated list contains zero or more results that
	// correspond to consecutive portions of the audio currently being processed.
	// It contains zero or one `is_final=true` result (the newly settled portion),
	// followed by zero or more `is_final=false` results.
	Results []*StreamingRecognitionResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
	// [Output-only] Indicates the lowest index in the `results` array that has
	// changed. The repeated `SpeechRecognitionResult` results overwrite past
	// results at this index and higher.
	ResultIndex int32 `protobuf:"varint,3,opt,name=result_index,json=resultIndex" json:"result_index,omitempty"`
	// [Output-only] Indicates the type of endpointer event.
	EndpointerType StreamingRecognizeResponse_EndpointerType `protobuf:"varint,4,opt,name=endpointer_type,json=endpointerType,enum=google.cloud.speech.v1beta1.StreamingRecognizeResponse_EndpointerType" json:"endpointer_type,omitempty"`
}

func (m *StreamingRecognizeResponse) Reset()                    { *m = StreamingRecognizeResponse{} }
func (m *StreamingRecognizeResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamingRecognizeResponse) ProtoMessage()               {}
func (*StreamingRecognizeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *StreamingRecognizeResponse) GetError() *google_rpc.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *StreamingRecognizeResponse) GetResults() []*StreamingRecognitionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// A speech recognition result corresponding to a portion of the audio that is
// currently being processed.
type StreamingRecognitionResult struct {
	// [Output-only] May contain one or more recognition hypotheses (up to the
	// maximum specified in `max_alternatives`).
	Alternatives []*SpeechRecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives" json:"alternatives,omitempty"`
	// [Output-only] If `false`, this `SpeechRecognitionResult` represents an
	// interim result that may change. If `true`, this is the final time the
	// speech service will return this particular `SpeechRecognitionResult`,
	// the recognizer will not return any further hypotheses for this portion of
	// the transcript and corresponding audio.
	IsFinal bool `protobuf:"varint,2,opt,name=is_final,json=isFinal" json:"is_final,omitempty"`
	// [Output-only] An estimate of the probability that the recognizer will not
	// change its guess about this interim result. Values range from 0.0
	// (completely unstable) to 1.0 (completely stable). Note that this is not the
	// same as `confidence`, which estimates the probability that a recognition
	// result is correct.
	// This field is only provided for interim results (`is_final=false`).
	// The default of 0.0 is a sentinel value indicating stability was not set.
	Stability float32 `protobuf:"fixed32,3,opt,name=stability" json:"stability,omitempty"`
}

func (m *StreamingRecognitionResult) Reset()                    { *m = StreamingRecognitionResult{} }
func (m *StreamingRecognitionResult) String() string            { return proto.CompactTextString(m) }
func (*StreamingRecognitionResult) ProtoMessage()               {}
func (*StreamingRecognitionResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *StreamingRecognitionResult) GetAlternatives() []*SpeechRecognitionAlternative {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

// A speech recognition result corresponding to a portion of the audio.
type SpeechRecognitionResult struct {
	// [Output-only] May contain one or more recognition hypotheses (up to the
	// maximum specified in `max_alternatives`).
	Alternatives []*SpeechRecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives" json:"alternatives,omitempty"`
}

func (m *SpeechRecognitionResult) Reset()                    { *m = SpeechRecognitionResult{} }
func (m *SpeechRecognitionResult) String() string            { return proto.CompactTextString(m) }
func (*SpeechRecognitionResult) ProtoMessage()               {}
func (*SpeechRecognitionResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SpeechRecognitionResult) GetAlternatives() []*SpeechRecognitionAlternative {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

// Alternative hypotheses (a.k.a. n-best list).
type SpeechRecognitionAlternative struct {
	// [Output-only] Transcript text representing the words that the user spoke.
	Transcript string `protobuf:"bytes,1,opt,name=transcript" json:"transcript,omitempty"`
	// [Output-only] The confidence estimate between 0.0 and 1.0. A higher number
	// means the system is more confident that the recognition is correct.
	// This field is typically provided only for the top hypothesis, and only for
	// `is_final=true` results.
	// The default of 0.0 is a sentinel value indicating confidence was not set.
	Confidence float32 `protobuf:"fixed32,2,opt,name=confidence" json:"confidence,omitempty"`
}

func (m *SpeechRecognitionAlternative) Reset()                    { *m = SpeechRecognitionAlternative{} }
func (m *SpeechRecognitionAlternative) String() string            { return proto.CompactTextString(m) }
func (*SpeechRecognitionAlternative) ProtoMessage()               {}
func (*SpeechRecognitionAlternative) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func init() {
	proto.RegisterType((*SyncRecognizeRequest)(nil), "google.cloud.speech.v1beta1.SyncRecognizeRequest")
	proto.RegisterType((*AsyncRecognizeRequest)(nil), "google.cloud.speech.v1beta1.AsyncRecognizeRequest")
	proto.RegisterType((*StreamingRecognizeRequest)(nil), "google.cloud.speech.v1beta1.StreamingRecognizeRequest")
	proto.RegisterType((*StreamingRecognitionConfig)(nil), "google.cloud.speech.v1beta1.StreamingRecognitionConfig")
	proto.RegisterType((*RecognitionConfig)(nil), "google.cloud.speech.v1beta1.RecognitionConfig")
	proto.RegisterType((*SpeechContext)(nil), "google.cloud.speech.v1beta1.SpeechContext")
	proto.RegisterType((*RecognitionAudio)(nil), "google.cloud.speech.v1beta1.RecognitionAudio")
	proto.RegisterType((*SyncRecognizeResponse)(nil), "google.cloud.speech.v1beta1.SyncRecognizeResponse")
	proto.RegisterType((*AsyncRecognizeResponse)(nil), "google.cloud.speech.v1beta1.AsyncRecognizeResponse")
	proto.RegisterType((*StreamingRecognizeResponse)(nil), "google.cloud.speech.v1beta1.StreamingRecognizeResponse")
	proto.RegisterType((*StreamingRecognitionResult)(nil), "google.cloud.speech.v1beta1.StreamingRecognitionResult")
	proto.RegisterType((*SpeechRecognitionResult)(nil), "google.cloud.speech.v1beta1.SpeechRecognitionResult")
	proto.RegisterType((*SpeechRecognitionAlternative)(nil), "google.cloud.speech.v1beta1.SpeechRecognitionAlternative")
	proto.RegisterEnum("google.cloud.speech.v1beta1.RecognitionConfig_AudioEncoding", RecognitionConfig_AudioEncoding_name, RecognitionConfig_AudioEncoding_value)
	proto.RegisterEnum("google.cloud.speech.v1beta1.StreamingRecognizeResponse_EndpointerType", StreamingRecognizeResponse_EndpointerType_name, StreamingRecognizeResponse_EndpointerType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Speech service

type SpeechClient interface {
	// Perform synchronous speech-recognition: receive results after all audio
	// has been sent and processed.
	SyncRecognize(ctx context.Context, in *SyncRecognizeRequest, opts ...grpc.CallOption) (*SyncRecognizeResponse, error)
	// Perform asynchronous speech-recognition: receive results via the
	// google.longrunning.Operations interface. `Operation.response` returns
	// `AsyncRecognizeResponse`.
	AsyncRecognize(ctx context.Context, in *AsyncRecognizeRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Perform bidirectional streaming speech-recognition: receive results while
	// sending audio. This method is only available via the gRPC API (not REST).
	StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Speech_StreamingRecognizeClient, error)
}

type speechClient struct {
	cc *grpc.ClientConn
}

func NewSpeechClient(cc *grpc.ClientConn) SpeechClient {
	return &speechClient{cc}
}

func (c *speechClient) SyncRecognize(ctx context.Context, in *SyncRecognizeRequest, opts ...grpc.CallOption) (*SyncRecognizeResponse, error) {
	out := new(SyncRecognizeResponse)
	err := grpc.Invoke(ctx, "/google.cloud.speech.v1beta1.Speech/SyncRecognize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechClient) AsyncRecognize(ctx context.Context, in *AsyncRecognizeRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.cloud.speech.v1beta1.Speech/AsyncRecognize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechClient) StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Speech_StreamingRecognizeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Speech_serviceDesc.Streams[0], c.cc, "/google.cloud.speech.v1beta1.Speech/StreamingRecognize", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechStreamingRecognizeClient{stream}
	return x, nil
}

type Speech_StreamingRecognizeClient interface {
	Send(*StreamingRecognizeRequest) error
	Recv() (*StreamingRecognizeResponse, error)
	grpc.ClientStream
}

type speechStreamingRecognizeClient struct {
	grpc.ClientStream
}

func (x *speechStreamingRecognizeClient) Send(m *StreamingRecognizeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *speechStreamingRecognizeClient) Recv() (*StreamingRecognizeResponse, error) {
	m := new(StreamingRecognizeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Speech service

type SpeechServer interface {
	// Perform synchronous speech-recognition: receive results after all audio
	// has been sent and processed.
	SyncRecognize(context.Context, *SyncRecognizeRequest) (*SyncRecognizeResponse, error)
	// Perform asynchronous speech-recognition: receive results via the
	// google.longrunning.Operations interface. `Operation.response` returns
	// `AsyncRecognizeResponse`.
	AsyncRecognize(context.Context, *AsyncRecognizeRequest) (*google_longrunning.Operation, error)
	// Perform bidirectional streaming speech-recognition: receive results while
	// sending audio. This method is only available via the gRPC API (not REST).
	StreamingRecognize(Speech_StreamingRecognizeServer) error
}

func RegisterSpeechServer(s *grpc.Server, srv SpeechServer) {
	s.RegisterService(&_Speech_serviceDesc, srv)
}

func _Speech_SyncRecognize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRecognizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).SyncRecognize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.speech.v1beta1.Speech/SyncRecognize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).SyncRecognize(ctx, req.(*SyncRecognizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Speech_AsyncRecognize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AsyncRecognizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServer).AsyncRecognize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.speech.v1beta1.Speech/AsyncRecognize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServer).AsyncRecognize(ctx, req.(*AsyncRecognizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Speech_StreamingRecognize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SpeechServer).StreamingRecognize(&speechStreamingRecognizeServer{stream})
}

type Speech_StreamingRecognizeServer interface {
	Send(*StreamingRecognizeResponse) error
	Recv() (*StreamingRecognizeRequest, error)
	grpc.ServerStream
}

type speechStreamingRecognizeServer struct {
	grpc.ServerStream
}

func (x *speechStreamingRecognizeServer) Send(m *StreamingRecognizeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *speechStreamingRecognizeServer) Recv() (*StreamingRecognizeRequest, error) {
	m := new(StreamingRecognizeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Speech_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.speech.v1beta1.Speech",
	HandlerType: (*SpeechServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncRecognize",
			Handler:    _Speech_SyncRecognize_Handler,
		},
		{
			MethodName: "AsyncRecognize",
			Handler:    _Speech_AsyncRecognize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingRecognize",
			Handler:       _Speech_StreamingRecognize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() {
	proto.RegisterFile("google.golang.org/genproto/googleapis/cloud/speech/v1beta1/cloud_speech.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1115 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x6e, 0x1b, 0xb7,
	0x13, 0xf6, 0x4a, 0x96, 0xff, 0x8c, 0x25, 0x79, 0xc3, 0x24, 0xbf, 0x9f, 0xe2, 0xe6, 0x8f, 0xbb,
	0x41, 0x51, 0x27, 0x40, 0xa5, 0xd8, 0x2d, 0x12, 0x34, 0x68, 0x0f, 0x92, 0xbc, 0xaa, 0x05, 0xc4,
	0xb2, 0x43, 0xc9, 0x4d, 0x2f, 0xed, 0x82, 0x59, 0xd1, 0x1b, 0x02, 0x12, 0xb9, 0x25, 0xa9, 0xc0,
	0xee, 0x31, 0xb7, 0x5e, 0x7a, 0xe9, 0x0b, 0x14, 0x68, 0x9f, 0xa0, 0xe8, 0xa1, 0x97, 0xa2, 0xd7,
	0xde, 0xfb, 0x0a, 0x7d, 0x90, 0x62, 0xc9, 0x5d, 0x5b, 0x92, 0x13, 0xc1, 0x2a, 0x1a, 0xa0, 0x27,
	0x89, 0x1f, 0x39, 0xdf, 0x7c, 0x1c, 0xce, 0xcc, 0x0e, 0xec, 0x47, 0x42, 0x44, 0x03, 0x5a, 0x8d,
	0xc4, 0x80, 0xf0, 0xa8, 0x2a, 0x64, 0x54, 0x8b, 0x28, 0x8f, 0xa5, 0xd0, 0xa2, 0x66, 0xb7, 0x48,
	0xcc, 0x54, 0x2d, 0x1c, 0x88, 0x51, 0xbf, 0xa6, 0x62, 0x4a, 0xc3, 0x17, 0xb5, 0x97, 0xdb, 0xcf,
	0xa9, 0x26, 0xdb, 0x16, 0x0c, 0x2c, 0x58, 0x35, 0x26, 0xe8, 0x9d, 0x94, 0xce, 0x6c, 0x55, 0xd3,
	0xad, 0xf4, 0xfc, 0x46, 0xfb, 0x72, 0xbe, 0x48, 0xcc, 0x6a, 0x8a, 0xca, 0x97, 0x2c, 0xa4, 0xa1,
	0xe0, 0xc7, 0x2c, 0xaa, 0x11, 0xce, 0x85, 0x26, 0x9a, 0x09, 0xae, 0xac, 0x9f, 0x8d, 0xc6, 0xe5,
	0xa8, 0x06, 0x82, 0x47, 0x72, 0xc4, 0x39, 0xe3, 0x51, 0x4d, 0xc4, 0x54, 0x4e, 0x70, 0x7c, 0x7a,
	0x39, 0x0e, 0x19, 0x87, 0x35, 0xa5, 0x89, 0x1e, 0xa9, 0xf4, 0xc7, 0x9a, 0x7b, 0x3f, 0x3a, 0x70,
	0xad, 0x7b, 0xca, 0x43, 0x4c, 0x43, 0x11, 0x71, 0xf6, 0x0d, 0xc5, 0xf4, 0xeb, 0x11, 0x55, 0x1a,
	0xb5, 0x60, 0xc9, 0xea, 0xae, 0x38, 0x9b, 0xce, 0xd6, 0xda, 0x4e, 0xb5, 0x3a, 0x23, 0x28, 0xd5,
	0xd4, 0x3c, 0x11, 0xd6, 0x34, 0x56, 0x38, 0xb5, 0x46, 0x4d, 0x28, 0x90, 0x51, 0x9f, 0x89, 0x4a,
	0xce, 0xd0, 0x7c, 0x70, 0x59, 0x9a, 0x7a, 0x62, 0x84, 0xad, 0xad, 0xf7, 0x93, 0x03, 0xd7, 0xeb,
	0xea, 0x3f, 0x2f, 0xf3, 0x37, 0x07, 0x6e, 0x74, 0xb5, 0xa4, 0x64, 0xc8, 0x78, 0x74, 0x41, 0x6a,
	0x1f, 0x5c, 0x95, 0x6d, 0x06, 0x13, 0xa2, 0x1f, 0xcd, 0xf4, 0x36, 0xcd, 0x78, 0xae, 0x7e, 0x6f,
	0x01, 0xaf, 0x9f, 0x51, 0x5a, 0x08, 0xbd, 0x07, 0x25, 0x23, 0x26, 0xf1, 0xa0, 0x29, 0xd7, 0xe6,
	0x42, 0xc5, 0xbd, 0x05, 0x5c, 0x34, 0x70, 0xd3, 0xa2, 0x8d, 0xab, 0x70, 0xe5, 0x5c, 0x8c, 0xb4,
	0x0a, 0xbd, 0x5f, 0x1d, 0xd8, 0x78, 0xb3, 0xb7, 0x7f, 0x2d, 0xd6, 0xf7, 0xc0, 0x55, 0x8c, 0x47,
	0x03, 0x1a, 0x8c, 0xb4, 0xa6, 0x92, 0xf0, 0x90, 0x1a, 0x95, 0x2b, 0x78, 0xdd, 0xe2, 0x47, 0x19,
	0x8c, 0xde, 0x87, 0x75, 0xc6, 0x35, 0x95, 0x6c, 0x18, 0x48, 0xaa, 0x46, 0x03, 0xad, 0x2a, 0x79,
	0x73, 0xb2, 0x9c, 0xc2, 0xd8, 0xa2, 0xde, 0xef, 0x79, 0xb8, 0x72, 0x51, 0xf1, 0x17, 0xb0, 0x42,
	0x79, 0x28, 0xfa, 0x8c, 0x5b, 0xcd, 0xe5, 0x9d, 0x4f, 0xe6, 0xd3, 0x5c, 0x35, 0xef, 0xeb, 0xa7,
	0x1c, 0xf8, 0x8c, 0x0d, 0xdd, 0x81, 0x35, 0x45, 0x86, 0xf1, 0x80, 0x06, 0x92, 0x68, 0x2b, 0xbf,
	0x80, 0xc1, 0x42, 0x98, 0x68, 0x8a, 0xee, 0x42, 0x29, 0x29, 0xc8, 0x11, 0x89, 0x68, 0x10, 0x8a,
	0x3e, 0x35, 0xba, 0x57, 0x71, 0x31, 0x03, 0x9b, 0xa2, 0x4f, 0x93, 0x48, 0x0c, 0xc9, 0x49, 0x40,
	0x06, 0x9a, 0x4a, 0x4e, 0x34, 0x7b, 0x49, 0x55, 0x65, 0xd1, 0x50, 0xad, 0x0f, 0xc9, 0x49, 0x7d,
	0x0c, 0x4e, 0x8e, 0xc6, 0x52, 0x1c, 0x13, 0xce, 0xf4, 0x69, 0x70, 0xcc, 0x92, 0xad, 0x4a, 0xc1,
	0x06, 0xed, 0x0c, 0x6f, 0x19, 0x18, 0x3d, 0x85, 0xb2, 0xbd, 0x97, 0xcd, 0x81, 0x13, 0x5d, 0x59,
	0x32, 0xef, 0x75, 0x7f, 0x76, 0x9a, 0x99, 0x65, 0xd3, 0x5a, 0xe0, 0x92, 0x1a, 0x5f, 0x7a, 0x04,
	0x4a, 0x13, 0x91, 0x40, 0x15, 0xb8, 0xe6, 0x77, 0x9a, 0x07, 0xbb, 0xed, 0xce, 0x67, 0xc1, 0x51,
	0xa7, 0x7b, 0xe8, 0x37, 0xdb, 0xad, 0xb6, 0xbf, 0xeb, 0x2e, 0xa0, 0x22, 0xac, 0x3c, 0x69, 0x77,
	0xfc, 0x3a, 0xde, 0x7e, 0xe8, 0x3a, 0x68, 0x05, 0x16, 0x5b, 0x4f, 0xea, 0x4d, 0x37, 0x87, 0x56,
	0xa1, 0xb0, 0x7f, 0xf4, 0xa4, 0xfe, 0xcc, 0xcd, 0xa3, 0x65, 0xc8, 0xd7, 0xf7, 0xb1, 0xbb, 0x88,
	0x00, 0x96, 0xea, 0xfb, 0x38, 0x78, 0xd6, 0x70, 0x0b, 0xde, 0x3d, 0x28, 0x4d, 0x48, 0x40, 0x15,
	0x58, 0x8e, 0x5f, 0x48, 0xa2, 0xa8, 0xaa, 0x38, 0x9b, 0xf9, 0xad, 0x55, 0x9c, 0x2d, 0x3d, 0x0c,
	0xee, 0x74, 0x09, 0xa2, 0x0d, 0x58, 0xce, 0x32, 0xde, 0x49, 0x33, 0x3e, 0x03, 0x10, 0x82, 0xfc,
	0x48, 0x32, 0xf3, 0x48, 0xab, 0x7b, 0x0b, 0x38, 0x59, 0x34, 0xca, 0x60, 0x0b, 0x22, 0x50, 0x62,
	0x24, 0x43, 0xea, 0x45, 0x70, 0x7d, 0xaa, 0x0f, 0xaa, 0x58, 0x70, 0x45, 0x51, 0x07, 0x96, 0xb3,
	0xd4, 0xcb, 0x6d, 0xe6, 0xb7, 0xd6, 0x76, 0x3e, 0xba, 0x44, 0x18, 0xc7, 0xe4, 0xd9, 0x0c, 0xc5,
	0x19, 0x89, 0xf7, 0x02, 0xfe, 0x37, 0xdd, 0xca, 0xde, 0x92, 0xa7, 0x9f, 0xf3, 0x17, 0xcb, 0x79,
	0xcc, 0xdd, 0x16, 0x14, 0xa8, 0x94, 0x42, 0xa6, 0xd5, 0x8c, 0x32, 0x67, 0x32, 0x0e, 0xab, 0x5d,
	0xf3, 0x8d, 0xc0, 0xf6, 0x00, 0x7a, 0x3a, 0x2d, 0x6c, 0xfe, 0x86, 0x35, 0xa5, 0x0d, 0xbd, 0x0b,
	0x45, 0xfb, 0x37, 0x60, 0xbc, 0x4f, 0x4f, 0x4c, 0x75, 0x14, 0xf0, 0x9a, 0xc5, 0xda, 0x09, 0x84,
	0x04, 0xac, 0x53, 0xde, 0x8f, 0x85, 0xa9, 0xf4, 0x40, 0x9f, 0xc6, 0xd4, 0xd4, 0x46, 0x79, 0xa7,
	0x35, 0x97, 0xf7, 0xf3, 0x1b, 0x57, 0xfd, 0x33, 0xba, 0xde, 0x69, 0x4c, 0x71, 0x99, 0x4e, 0xac,
	0xbd, 0x57, 0x0e, 0x94, 0x27, 0x8f, 0xa0, 0x4d, 0xb8, 0xe9, 0x77, 0x76, 0x0f, 0x0f, 0xda, 0x9d,
	0x9e, 0x8f, 0x03, 0xff, 0x73, 0xbf, 0xd3, 0x9b, 0x4a, 0xf7, 0xab, 0xb0, 0xde, 0xed, 0xd5, 0x71,
	0x2f, 0x38, 0x68, 0x05, 0xdd, 0x43, 0xdf, 0x6f, 0xee, 0xb9, 0x0e, 0xba, 0x02, 0x25, 0xbf, 0xb3,
	0x3b, 0x06, 0xe5, 0x90, 0x0b, 0xc5, 0x14, 0xaa, 0x1f, 0xed, 0xb6, 0x0f, 0xdc, 0x3c, 0xba, 0x06,
	0x6e, 0x8a, 0x1c, 0xf5, 0x7a, 0x3e, 0xae, 0x77, 0x9a, 0xbe, 0xbb, 0xe8, 0xfd, 0xf2, 0x86, 0x1e,
	0x6c, 0x03, 0x88, 0xbe, 0x84, 0xe2, 0x44, 0xb7, 0x70, 0xcc, 0x7b, 0x7c, 0x3c, 0x5f, 0xa2, 0x8c,
	0x35, 0x16, 0x3c, 0x41, 0x87, 0x6e, 0xc0, 0x0a, 0x53, 0xc1, 0x31, 0xe3, 0x64, 0x90, 0xb6, 0xe4,
	0x65, 0xa6, 0x5a, 0xc9, 0x12, 0xdd, 0x84, 0x55, 0xa5, 0xc9, 0x73, 0x36, 0x60, 0xfa, 0xd4, 0x3c,
	0x57, 0x0e, 0x9f, 0x03, 0xde, 0x09, 0xfc, 0xff, 0x0d, 0xf9, 0xf8, 0x96, 0x25, 0x7b, 0x5f, 0xc1,
	0xcd, 0x59, 0xa7, 0xd1, 0x6d, 0x00, 0x2d, 0x09, 0x57, 0xa1, 0x64, 0xb1, 0xed, 0x0d, 0xab, 0x78,
	0x0c, 0x49, 0xf6, 0xcd, 0x77, 0xa9, 0x4f, 0xb3, 0xef, 0x50, 0x0e, 0x8f, 0x21, 0x3b, 0x7f, 0xe4,
	0x61, 0xc9, 0x3a, 0x40, 0x3f, 0x38, 0x50, 0x9a, 0x68, 0x12, 0x68, 0x7b, 0xf6, 0x2d, 0x5e, 0x33,
	0xb1, 0x6c, 0xec, 0xcc, 0x63, 0x62, 0x13, 0xd7, 0xdb, 0x7a, 0xf5, 0xe7, 0x5f, 0xdf, 0xe7, 0x3c,
	0xef, 0xd6, 0xd9, 0xd4, 0x6a, 0xcd, 0x1e, 0x27, 0x8d, 0x44, 0x66, 0xc7, 0x1f, 0x3b, 0xf7, 0xd1,
	0x77, 0x0e, 0x94, 0x27, 0xdb, 0x0b, 0x9a, 0xed, 0xf0, 0xb5, 0x63, 0xd5, 0xc6, 0xad, 0xcc, 0x66,
	0x6c, 0xf6, 0xac, 0x1e, 0x64, 0xb3, 0xa7, 0x77, 0xcf, 0xe8, 0xb9, 0xeb, 0xdd, 0x9e, 0xd6, 0x43,
	0x2e, 0x08, 0xfa, 0xd6, 0x01, 0x74, 0xb1, 0x24, 0xd1, 0xc3, 0xb9, 0x6b, 0xd8, 0x0a, 0x7b, 0xf4,
	0x0f, 0x6b, 0x7f, 0xcb, 0x79, 0xe0, 0x34, 0x1e, 0xc0, 0x9d, 0x50, 0x0c, 0x67, 0x31, 0x34, 0xd6,
	0xec, 0x53, 0x1f, 0x26, 0xc3, 0xf1, 0xa1, 0xf3, 0x7c, 0xc9, 0x4c, 0xc9, 0x1f, 0xfe, 0x1d, 0x00,
	0x00, 0xff, 0xff, 0x89, 0x6f, 0xfa, 0x0f, 0x61, 0x0c, 0x00, 0x00,
}

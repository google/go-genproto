// Code generated by protoc-gen-go.
// source: google/logging/v2/logging_config.proto
// DO NOT EDIT!

package logging

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf5 "github.com/golang/protobuf/ptypes/empty"
import google_protobuf4 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Available log entry formats. Log entries can be written to Stackdriver
// Logging in either format and can be exported in either format.
// Version 2 is the preferred format.
type LogSink_VersionFormat int32

const (
	// An unspecified version format will default to V2.
	LogSink_VERSION_FORMAT_UNSPECIFIED LogSink_VersionFormat = 0
	// `LogEntry` version 2 format.
	LogSink_V2 LogSink_VersionFormat = 1
	// `LogEntry` version 1 format.
	LogSink_V1 LogSink_VersionFormat = 2
)

var LogSink_VersionFormat_name = map[int32]string{
	0: "VERSION_FORMAT_UNSPECIFIED",
	1: "V2",
	2: "V1",
}
var LogSink_VersionFormat_value = map[string]int32{
	"VERSION_FORMAT_UNSPECIFIED": 0,
	"V2": 1,
	"V1": 2,
}

func (x LogSink_VersionFormat) String() string {
	return proto.EnumName(LogSink_VersionFormat_name, int32(x))
}
func (LogSink_VersionFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 0} }

// Describes a sink used to export log entries outside of Stackdriver Logging.
// A logs filter controls which log entries are exported.  Sinks can have a
// start time and an end time; these can be used to place log entries from an
// exact time range into a particular destination.  If both `start_time` and
// `end_time` are present, then `start_time` must be less than `end_time`.
type LogSink struct {
	// Required. The client-assigned sink identifier, unique within the
	// project. Example: `"my-syslog-errors-to-pubsub"`.  Sink identifiers are
	// limited to 100 characters and can include only the following characters:
	// upper and lower-case alphanumeric characters, underscores, hyphens, and
	// periods.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Required. The export destination:
	//
	//     "storage.googleapis.com/[GCS_BUCKET]"
	//     "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
	//     "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
	//
	// For more information,  see
	// [Exporting Logs With Sinks](/logging/docs/api/tasks/exporting-logs).
	Destination string `protobuf:"bytes,3,opt,name=destination" json:"destination,omitempty"`
	// Optional. An [advanced logs filter](/logging/docs/view/advanced_filters).
	// Only log entries matching the filter are exported. The filter
	// must be consistent with the log entry format specified by the
	// `outputVersionFormat` parameter, regardless of the format of the
	// log entry that was originally ingested by Stackdriver Logging.
	// The following example uses field names in the v2 log entry format:
	//
	//     logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR
	Filter string `protobuf:"bytes,5,opt,name=filter" json:"filter,omitempty"`
	// Optional. The log entry version to use for this sink's exported log
	// entries.  This version does not have to correspond to the version of the
	// log entry that was written to Stackdriver Logging. If omitted, the
	// v2 format is used.
	OutputVersionFormat LogSink_VersionFormat `protobuf:"varint,6,opt,name=output_version_format,json=outputVersionFormat,enum=google.logging.v2.LogSink_VersionFormat" json:"output_version_format,omitempty"`
	// Output only. An IAM identity&mdash;a service account or group&mdash;that
	// will write exported log entries to the destination on behalf of Stackdriver
	// Logging. You must grant this identity write-access to the destination.
	// Consult the destination service's documentation to determine the exact role
	// that must be granted.
	WriterIdentity string `protobuf:"bytes,8,opt,name=writer_identity,json=writerIdentity" json:"writer_identity,omitempty"`
	// Optional. The time at which this sink will begin exporting log entries.  If
	// this value is present, then log entries are exported only if `start_time`
	// <=`entry.timestamp`.
	StartTime *google_protobuf4.Timestamp `protobuf:"bytes,10,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Optional. Time at which this sink will stop exporting log entries.  If this
	// value is present, then log entries are exported only if `entry.timestamp` <
	// `end_time`.
	EndTime *google_protobuf4.Timestamp `protobuf:"bytes,11,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *LogSink) Reset()                    { *m = LogSink{} }
func (m *LogSink) String() string            { return proto.CompactTextString(m) }
func (*LogSink) ProtoMessage()               {}
func (*LogSink) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *LogSink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LogSink) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *LogSink) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *LogSink) GetOutputVersionFormat() LogSink_VersionFormat {
	if m != nil {
		return m.OutputVersionFormat
	}
	return LogSink_VERSION_FORMAT_UNSPECIFIED
}

func (m *LogSink) GetWriterIdentity() string {
	if m != nil {
		return m.WriterIdentity
	}
	return ""
}

func (m *LogSink) GetStartTime() *google_protobuf4.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *LogSink) GetEndTime() *google_protobuf4.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// The parameters to `ListSinks`.
type ListSinksRequest struct {
	// Required. The resource name where this sink was created:
	//
	//     "projects/[PROJECT_ID]"
	//     "organizations/[ORGANIZATION_ID]"
	Parent string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	// Optional. If present, then retrieve the next batch of results from the
	// preceding call to this method.  `pageToken` must be the value of
	// `nextPageToken` from the previous response.  The values of other method
	// parameters should be identical to those in the previous call.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// Optional. The maximum number of results to return from this request.
	// Non-positive values are ignored.  The presence of `nextPageToken` in the
	// response indicates that more results might be available.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *ListSinksRequest) Reset()                    { *m = ListSinksRequest{} }
func (m *ListSinksRequest) String() string            { return proto.CompactTextString(m) }
func (*ListSinksRequest) ProtoMessage()               {}
func (*ListSinksRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ListSinksRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListSinksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListSinksRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// Result returned from `ListSinks`.
type ListSinksResponse struct {
	// A list of sinks.
	Sinks []*LogSink `protobuf:"bytes,1,rep,name=sinks" json:"sinks,omitempty"`
	// If there might be more results than appear in this response, then
	// `nextPageToken` is included.  To get the next set of results, call the same
	// method again using the value of `nextPageToken` as `pageToken`.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListSinksResponse) Reset()                    { *m = ListSinksResponse{} }
func (m *ListSinksResponse) String() string            { return proto.CompactTextString(m) }
func (*ListSinksResponse) ProtoMessage()               {}
func (*ListSinksResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *ListSinksResponse) GetSinks() []*LogSink {
	if m != nil {
		return m.Sinks
	}
	return nil
}

func (m *ListSinksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The parameters to `GetSink`.
type GetSinkRequest struct {
	// Required. The resource name of the sink to return:
	//
	//     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
	//     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
	SinkName string `protobuf:"bytes,1,opt,name=sink_name,json=sinkName" json:"sink_name,omitempty"`
}

func (m *GetSinkRequest) Reset()                    { *m = GetSinkRequest{} }
func (m *GetSinkRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSinkRequest) ProtoMessage()               {}
func (*GetSinkRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *GetSinkRequest) GetSinkName() string {
	if m != nil {
		return m.SinkName
	}
	return ""
}

// The parameters to `CreateSink`.
type CreateSinkRequest struct {
	// Required. The resource in which to create the sink:
	//
	//     "projects/[PROJECT_ID]"
	//     "organizations/[ORGANIZATION_ID]"
	Parent string `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	// Required. The new sink, whose `name` parameter is a sink identifier that
	// is not already in use.
	Sink *LogSink `protobuf:"bytes,2,opt,name=sink" json:"sink,omitempty"`
	// Optional. Whether the sink will have a dedicated service account returned
	// in the sink's writer_identity. Set this field to be true to export
	// logs from one project to a different project. This field is ignored for
	// non-project sinks (e.g. organization sinks) because those sinks are
	// required to have dedicated service accounts.
	UniqueWriterIdentity bool `protobuf:"varint,3,opt,name=unique_writer_identity,json=uniqueWriterIdentity" json:"unique_writer_identity,omitempty"`
}

func (m *CreateSinkRequest) Reset()                    { *m = CreateSinkRequest{} }
func (m *CreateSinkRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateSinkRequest) ProtoMessage()               {}
func (*CreateSinkRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *CreateSinkRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateSinkRequest) GetSink() *LogSink {
	if m != nil {
		return m.Sink
	}
	return nil
}

func (m *CreateSinkRequest) GetUniqueWriterIdentity() bool {
	if m != nil {
		return m.UniqueWriterIdentity
	}
	return false
}

// The parameters to `UpdateSink`.
type UpdateSinkRequest struct {
	// Required. The resource name of the sink to update, including the parent
	// resource and the sink identifier:
	//
	//     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
	//     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
	//
	// Example: `"projects/my-project-id/sinks/my-sink-id"`.
	SinkName string `protobuf:"bytes,1,opt,name=sink_name,json=sinkName" json:"sink_name,omitempty"`
	// Required. The updated sink, whose name is the same identifier that appears
	// as part of `sinkName`.  If `sinkName` does not exist, then
	// this method creates a new sink.
	Sink *LogSink `protobuf:"bytes,2,opt,name=sink" json:"sink,omitempty"`
	// Optional. Whether the sink will have a dedicated service account returned
	// in the sink's writer_identity. Set this field to be true to export
	// logs from one project to a different project. This field is ignored for
	// non-project sinks (e.g. organization sinks) because those sinks are
	// required to have dedicated service accounts.
	UniqueWriterIdentity bool `protobuf:"varint,3,opt,name=unique_writer_identity,json=uniqueWriterIdentity" json:"unique_writer_identity,omitempty"`
}

func (m *UpdateSinkRequest) Reset()                    { *m = UpdateSinkRequest{} }
func (m *UpdateSinkRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateSinkRequest) ProtoMessage()               {}
func (*UpdateSinkRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *UpdateSinkRequest) GetSinkName() string {
	if m != nil {
		return m.SinkName
	}
	return ""
}

func (m *UpdateSinkRequest) GetSink() *LogSink {
	if m != nil {
		return m.Sink
	}
	return nil
}

func (m *UpdateSinkRequest) GetUniqueWriterIdentity() bool {
	if m != nil {
		return m.UniqueWriterIdentity
	}
	return false
}

// The parameters to `DeleteSink`.
type DeleteSinkRequest struct {
	// Required. The resource name of the sink to delete, including the parent
	// resource and the sink identifier:
	//
	//     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
	//     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
	//
	// It is an error if the sink does not exist.
	SinkName string `protobuf:"bytes,1,opt,name=sink_name,json=sinkName" json:"sink_name,omitempty"`
}

func (m *DeleteSinkRequest) Reset()                    { *m = DeleteSinkRequest{} }
func (m *DeleteSinkRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteSinkRequest) ProtoMessage()               {}
func (*DeleteSinkRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *DeleteSinkRequest) GetSinkName() string {
	if m != nil {
		return m.SinkName
	}
	return ""
}

func init() {
	proto.RegisterType((*LogSink)(nil), "google.logging.v2.LogSink")
	proto.RegisterType((*ListSinksRequest)(nil), "google.logging.v2.ListSinksRequest")
	proto.RegisterType((*ListSinksResponse)(nil), "google.logging.v2.ListSinksResponse")
	proto.RegisterType((*GetSinkRequest)(nil), "google.logging.v2.GetSinkRequest")
	proto.RegisterType((*CreateSinkRequest)(nil), "google.logging.v2.CreateSinkRequest")
	proto.RegisterType((*UpdateSinkRequest)(nil), "google.logging.v2.UpdateSinkRequest")
	proto.RegisterType((*DeleteSinkRequest)(nil), "google.logging.v2.DeleteSinkRequest")
	proto.RegisterEnum("google.logging.v2.LogSink_VersionFormat", LogSink_VersionFormat_name, LogSink_VersionFormat_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ConfigServiceV2 service

type ConfigServiceV2Client interface {
	// Lists sinks.
	ListSinks(ctx context.Context, in *ListSinksRequest, opts ...grpc.CallOption) (*ListSinksResponse, error)
	// Gets a sink.
	GetSink(ctx context.Context, in *GetSinkRequest, opts ...grpc.CallOption) (*LogSink, error)
	// Creates a sink.
	CreateSink(ctx context.Context, in *CreateSinkRequest, opts ...grpc.CallOption) (*LogSink, error)
	// Updates or creates a sink.
	UpdateSink(ctx context.Context, in *UpdateSinkRequest, opts ...grpc.CallOption) (*LogSink, error)
	// Deletes a sink.
	DeleteSink(ctx context.Context, in *DeleteSinkRequest, opts ...grpc.CallOption) (*google_protobuf5.Empty, error)
}

type configServiceV2Client struct {
	cc *grpc.ClientConn
}

func NewConfigServiceV2Client(cc *grpc.ClientConn) ConfigServiceV2Client {
	return &configServiceV2Client{cc}
}

func (c *configServiceV2Client) ListSinks(ctx context.Context, in *ListSinksRequest, opts ...grpc.CallOption) (*ListSinksResponse, error) {
	out := new(ListSinksResponse)
	err := grpc.Invoke(ctx, "/google.logging.v2.ConfigServiceV2/ListSinks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceV2Client) GetSink(ctx context.Context, in *GetSinkRequest, opts ...grpc.CallOption) (*LogSink, error) {
	out := new(LogSink)
	err := grpc.Invoke(ctx, "/google.logging.v2.ConfigServiceV2/GetSink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceV2Client) CreateSink(ctx context.Context, in *CreateSinkRequest, opts ...grpc.CallOption) (*LogSink, error) {
	out := new(LogSink)
	err := grpc.Invoke(ctx, "/google.logging.v2.ConfigServiceV2/CreateSink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceV2Client) UpdateSink(ctx context.Context, in *UpdateSinkRequest, opts ...grpc.CallOption) (*LogSink, error) {
	out := new(LogSink)
	err := grpc.Invoke(ctx, "/google.logging.v2.ConfigServiceV2/UpdateSink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceV2Client) DeleteSink(ctx context.Context, in *DeleteSinkRequest, opts ...grpc.CallOption) (*google_protobuf5.Empty, error) {
	out := new(google_protobuf5.Empty)
	err := grpc.Invoke(ctx, "/google.logging.v2.ConfigServiceV2/DeleteSink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ConfigServiceV2 service

type ConfigServiceV2Server interface {
	// Lists sinks.
	ListSinks(context.Context, *ListSinksRequest) (*ListSinksResponse, error)
	// Gets a sink.
	GetSink(context.Context, *GetSinkRequest) (*LogSink, error)
	// Creates a sink.
	CreateSink(context.Context, *CreateSinkRequest) (*LogSink, error)
	// Updates or creates a sink.
	UpdateSink(context.Context, *UpdateSinkRequest) (*LogSink, error)
	// Deletes a sink.
	DeleteSink(context.Context, *DeleteSinkRequest) (*google_protobuf5.Empty, error)
}

func RegisterConfigServiceV2Server(s *grpc.Server, srv ConfigServiceV2Server) {
	s.RegisterService(&_ConfigServiceV2_serviceDesc, srv)
}

func _ConfigServiceV2_ListSinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceV2Server).ListSinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.logging.v2.ConfigServiceV2/ListSinks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceV2Server).ListSinks(ctx, req.(*ListSinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigServiceV2_GetSink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceV2Server).GetSink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.logging.v2.ConfigServiceV2/GetSink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceV2Server).GetSink(ctx, req.(*GetSinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigServiceV2_CreateSink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceV2Server).CreateSink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.logging.v2.ConfigServiceV2/CreateSink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceV2Server).CreateSink(ctx, req.(*CreateSinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigServiceV2_UpdateSink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceV2Server).UpdateSink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.logging.v2.ConfigServiceV2/UpdateSink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceV2Server).UpdateSink(ctx, req.(*UpdateSinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigServiceV2_DeleteSink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceV2Server).DeleteSink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.logging.v2.ConfigServiceV2/DeleteSink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceV2Server).DeleteSink(ctx, req.(*DeleteSinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigServiceV2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.logging.v2.ConfigServiceV2",
	HandlerType: (*ConfigServiceV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSinks",
			Handler:    _ConfigServiceV2_ListSinks_Handler,
		},
		{
			MethodName: "GetSink",
			Handler:    _ConfigServiceV2_GetSink_Handler,
		},
		{
			MethodName: "CreateSink",
			Handler:    _ConfigServiceV2_CreateSink_Handler,
		},
		{
			MethodName: "UpdateSink",
			Handler:    _ConfigServiceV2_UpdateSink_Handler,
		},
		{
			MethodName: "DeleteSink",
			Handler:    _ConfigServiceV2_DeleteSink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/logging/v2/logging_config.proto",
}

func init() { proto.RegisterFile("google/logging/v2/logging_config.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x7f, 0x4f, 0xfb, 0x44,
	0x18, 0xb7, 0x03, 0xc6, 0xf6, 0x10, 0x60, 0x3b, 0xfd, 0x62, 0x53, 0x44, 0x66, 0x05, 0x5c, 0x66,
	0x6c, 0xb1, 0x6a, 0xe2, 0x8f, 0x18, 0x23, 0x63, 0x90, 0x25, 0x08, 0xa4, 0x83, 0x99, 0x18, 0x93,
	0xa6, 0x6c, 0xb7, 0xe6, 0x64, 0xbd, 0x2b, 0xed, 0x6d, 0x0a, 0x48, 0x62, 0x7c, 0x07, 0xc4, 0xc4,
	0x17, 0xe1, 0xdb, 0xf1, 0x2d, 0xf8, 0x3a, 0x8c, 0xb9, 0xbb, 0x0e, 0xb6, 0x75, 0x4e, 0xfe, 0xf2,
	0xaf, 0xde, 0xf3, 0xeb, 0x3e, 0x9f, 0xe7, 0x79, 0x3e, 0xb9, 0xc2, 0x5e, 0xc0, 0x58, 0xd0, 0xc7,
	0x76, 0x9f, 0x05, 0x01, 0xa1, 0x81, 0x3d, 0x74, 0x46, 0x47, 0xaf, 0xc3, 0x68, 0x8f, 0x04, 0x56,
	0x14, 0x33, 0xce, 0x50, 0x59, 0xe5, 0x59, 0x69, 0xd0, 0x1a, 0x3a, 0xc6, 0x5b, 0x69, 0xa9, 0x1f,
	0x11, 0xdb, 0xa7, 0x94, 0x71, 0x9f, 0x13, 0x46, 0x13, 0x55, 0x60, 0x6c, 0xa6, 0x51, 0x69, 0x5d,
	0x0d, 0x7a, 0x36, 0x0e, 0x23, 0x7e, 0x9b, 0x06, 0xb7, 0xa7, 0x83, 0x9c, 0x84, 0x38, 0xe1, 0x7e,
	0x18, 0xa9, 0x04, 0xf3, 0x71, 0x01, 0x96, 0x4f, 0x58, 0xd0, 0x22, 0xf4, 0x1a, 0x21, 0x58, 0xa4,
	0x7e, 0x88, 0x75, 0xad, 0xa2, 0x55, 0x8b, 0xae, 0x3c, 0xa3, 0x0a, 0xac, 0x74, 0x71, 0xc2, 0x09,
	0x95, 0x98, 0xfa, 0x82, 0x0c, 0x8d, 0xbb, 0xd0, 0x06, 0xe4, 0x7b, 0xa4, 0xcf, 0x71, 0xac, 0x2f,
	0xc9, 0x60, 0x6a, 0xa1, 0xef, 0xe1, 0x15, 0x1b, 0xf0, 0x68, 0xc0, 0xbd, 0x21, 0x8e, 0x13, 0xc2,
	0xa8, 0xd7, 0x63, 0x71, 0xe8, 0x73, 0x3d, 0x5f, 0xd1, 0xaa, 0x6b, 0x4e, 0xd5, 0xca, 0x34, 0x6a,
	0xa5, 0x44, 0xac, 0xb6, 0x2a, 0x38, 0x92, 0xf9, 0xee, 0xeb, 0xea, 0x9a, 0x09, 0x27, 0x7a, 0x0f,
	0xd6, 0x7f, 0x8c, 0x09, 0xc7, 0xb1, 0x47, 0xba, 0x98, 0x72, 0xc2, 0x6f, 0xf5, 0x82, 0x84, 0x5f,
	0x53, 0xee, 0x66, 0xea, 0x45, 0x9f, 0x01, 0x24, 0xdc, 0x8f, 0xb9, 0x27, 0x3a, 0xd7, 0xa1, 0xa2,
	0x55, 0x57, 0x1c, 0x63, 0x84, 0x3d, 0x1a, 0x8b, 0x75, 0x31, 0x1a, 0x8b, 0x5b, 0x94, 0xd9, 0xc2,
	0x46, 0x9f, 0x40, 0x01, 0xd3, 0xae, 0x2a, 0x5c, 0xf9, 0xcf, 0xc2, 0x65, 0x4c, 0xbb, 0xc2, 0x32,
	0xbf, 0x82, 0xd5, 0x49, 0xae, 0x6f, 0x83, 0xd1, 0x6e, 0xb8, 0xad, 0xe6, 0xd9, 0xa9, 0x77, 0x74,
	0xe6, 0x7e, 0xf3, 0xf5, 0x85, 0x77, 0x79, 0xda, 0x3a, 0x6f, 0xd4, 0x9b, 0x47, 0xcd, 0xc6, 0x61,
	0xe9, 0x35, 0x94, 0x87, 0x5c, 0xdb, 0x29, 0x69, 0xf2, 0xfb, 0x61, 0x29, 0x67, 0xf6, 0xa0, 0x74,
	0x42, 0x12, 0x2e, 0x46, 0x91, 0xb8, 0xf8, 0x66, 0x80, 0x13, 0x2e, 0xa6, 0x1c, 0xf9, 0x31, 0xa6,
	0x3c, 0xdd, 0x4e, 0x6a, 0xa1, 0x2d, 0x80, 0xc8, 0x0f, 0xb0, 0xc7, 0xd9, 0x35, 0xa6, 0x7a, 0x4e,
	0xc6, 0x8a, 0xc2, 0x73, 0x21, 0x1c, 0x68, 0x13, 0xa4, 0xe1, 0x25, 0xe4, 0x0e, 0xcb, 0xe5, 0x2d,
	0xb9, 0x05, 0xe1, 0x68, 0x91, 0x3b, 0x6c, 0x86, 0x50, 0x1e, 0xc3, 0x49, 0x22, 0x46, 0x13, 0x8c,
	0xf6, 0x61, 0x29, 0x11, 0x0e, 0x5d, 0xab, 0x2c, 0x8c, 0x77, 0x9c, 0x5d, 0x93, 0xab, 0x12, 0xd1,
	0x1e, 0xac, 0x53, 0xfc, 0x13, 0xf7, 0x32, 0x3c, 0x56, 0x85, 0xfb, 0x7c, 0xc4, 0xc5, 0xfc, 0x00,
	0xd6, 0x8e, 0xb1, 0x44, 0x1b, 0x35, 0xb5, 0x09, 0x45, 0x71, 0x85, 0x37, 0xa6, 0xba, 0x82, 0x70,
	0x9c, 0xfa, 0x21, 0x36, 0x1f, 0x35, 0x28, 0xd7, 0x63, 0xec, 0x73, 0x3c, 0x5e, 0xf2, 0x6f, 0x73,
	0xb0, 0x60, 0x51, 0x54, 0x4a, 0xe4, 0xf9, 0xac, 0x65, 0x1e, 0xfa, 0x18, 0x36, 0x06, 0x94, 0xdc,
	0x0c, 0xb0, 0x37, 0x2d, 0x23, 0x31, 0xa5, 0x82, 0xfb, 0x86, 0x8a, 0x7e, 0x3b, 0x21, 0x26, 0xf3,
	0x77, 0x0d, 0xca, 0x97, 0x51, 0x77, 0x8a, 0xd3, 0xbc, 0x36, 0xfe, 0x27, 0x62, 0xfb, 0x50, 0x3e,
	0xc4, 0x7d, 0xfc, 0x72, 0x5e, 0xce, 0xdf, 0x8b, 0xb0, 0x5e, 0x97, 0x0f, 0x4f, 0x0b, 0xc7, 0x43,
	0xd2, 0xc1, 0x6d, 0x07, 0x3d, 0x40, 0xf1, 0x49, 0x10, 0xe8, 0xdd, 0x59, 0x54, 0xa7, 0x64, 0x69,
	0xec, 0xcc, 0x4f, 0x52, 0x9a, 0x32, 0x77, 0x7f, 0xfd, 0xf3, 0xaf, 0xdf, 0x72, 0xdb, 0x68, 0x4b,
	0xbc, 0x7a, 0xf7, 0x6a, 0x63, 0x5f, 0x46, 0x31, 0xfb, 0x01, 0x77, 0x78, 0x62, 0xd7, 0x1e, 0x6c,
	0x25, 0x24, 0x0e, 0xcb, 0xa9, 0x40, 0xd0, 0x3b, 0x33, 0xee, 0x9d, 0x14, 0x8f, 0x31, 0x67, 0x94,
	0x66, 0x4d, 0x02, 0xee, 0x20, 0x53, 0x02, 0x3e, 0x0d, 0x61, 0x0c, 0x53, 0x41, 0xda, 0xb5, 0x07,
	0x74, 0x0f, 0xf0, 0x2c, 0x33, 0x34, 0xab, 0xa1, 0x8c, 0x0a, 0xe7, 0x62, 0xbf, 0x2f, 0xb1, 0x77,
	0xcd, 0xf9, 0xcd, 0x7e, 0xae, 0xb6, 0xfd, 0x8b, 0x06, 0xf0, 0x2c, 0xa8, 0x99, 0xe8, 0x19, 0xbd,
	0xcd, 0x45, 0xdf, 0x97, 0xe8, 0x35, 0xe3, 0x05, 0x9d, 0xa7, 0x14, 0x86, 0x00, 0xcf, 0xd2, 0x99,
	0xc9, 0x20, 0xa3, 0x2c, 0x63, 0x23, 0xf3, 0x0e, 0x36, 0xc4, 0x4f, 0x67, 0x34, 0xf7, 0xda, 0x0b,
	0xd0, 0x0f, 0x7e, 0x86, 0x57, 0x1d, 0x16, 0x66, 0xe1, 0x0e, 0x56, 0x4f, 0xd4, 0x59, 0xa9, 0xf3,
	0x5c, 0xfb, 0xee, 0xd3, 0x34, 0x27, 0x60, 0x7d, 0x9f, 0x06, 0x16, 0x8b, 0x03, 0x3b, 0xc0, 0x54,
	0x42, 0xdb, 0x2a, 0xe4, 0x47, 0x24, 0x19, 0xfb, 0xb3, 0x7e, 0x91, 0x1e, 0xff, 0xc8, 0xbd, 0x79,
	0xac, 0x4a, 0xeb, 0x7d, 0x36, 0xe8, 0x5a, 0xe9, 0xc5, 0x56, 0xdb, 0xb9, 0xca, 0xcb, 0xf2, 0x8f,
	0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x3b, 0x36, 0xbc, 0x97, 0x07, 0x00, 0x00,
}
